/** @file Main.c
 * Capture and write to a file all logs generated by Tomb Raider Chronicle executable.
 * @author Adrien RICCIARDI
 */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

//-------------------------------------------------------------------------------------------------
// Private constants
//-------------------------------------------------------------------------------------------------
/** Tomb Raider executable searches for this window class when trying to send logs to logging program. */
#define STRING_WINDOW_CLASS "DBLogWindowClass"

/** How big can be a message log string in bytes. */
#define LOG_MAXIMUM_MESSAGE_SIZE 2048
/** How many log types are sent by the game. */
#define LOG_TYPES_COUNT 9

//-------------------------------------------------------------------------------------------------
// Private types
//-------------------------------------------------------------------------------------------------
/** All log types are sent by the Tomb Raider executable on startup. */
typedef struct
{
	char String_Name[128]; //!< The log type name as sent on game startup.
	int Displaying_Color; //!< The color code to use when displaying this log.
} TLogType;

//-------------------------------------------------------------------------------------------------
// Private variables
//-------------------------------------------------------------------------------------------------
/** This file is memory mapped, it is where the Tomb Raider executable writes. */
HANDLE Handle_Binary_File;
/** The memory-map shared between this program and Tomb Raider executable. */
HANDLE Handle_Memory_Mapping;

/** Write the received logs to this file. */
static FILE *Pointer_Output_File;

/** Contain the UM_DBLOGOUT message dynamic identifier. */
static UINT Window_Message_ID_UM_DBLOGOUT;
/** Contain the UM_DBCLEARLOG message dynamic identifier. */
static UINT Window_Message_ID_UM_DBCLEARLOG;
/** Contain the UM_DBDEFTYPE message dynamic identifier. */
static UINT Window_Message_ID_UM_DBDEFTYPE;
/** Contain the UM_DBCOMMAND message dynamic identifier. */
static UINT Window_Message_ID_UM_DBCOMMAND;

/** Store all log types sent by the game. The amount of logs is fixed. */
static TLogType Log_Types[LOG_TYPES_COUNT] =
{
	{
		"NO TYPE",
		41
	},
	{
		"",
		31
	},
	{
		"",
		32
	},
	{
		"",
		33
	},
	{
		"",
		34
	},
	{
		"",
		35
	},
	{
		"",
		36
	},
	{
		"",
		40
	},
	{
		"",
		44
	}
};
/** How many log types have been set so far. */
static int Defined_Log_Types_Count = 1; // Log type '0' is existing even if it is not set by a "DBDEFTYPE" command

//-------------------------------------------------------------------------------------------------
// Private functions
//-------------------------------------------------------------------------------------------------
/** Read the memory-shared log file to fetch latest log type.
 * @param Pointer_String_Type_Name On output, contain a zero-terminated string corresponding to the log type name.
 * @return -1 if an error occurred,
 * @return 0 on success.
 */
static int ReadLogType(char *Pointer_String_Type_Name)
{
	FILE *Pointer_File;
	
	// Open the file everytime to start from the begining
	Pointer_File = fopen("Log.bin", "rb");
	if (Pointer_File == NULL)
	{
		printf("Error : failed to open log file to read last log type (%s).\n", strerror(errno));
		return -1;
	}
	else
	{
		// Read the log type name
		fread(Pointer_String_Type_Name, 1, LOG_MAXIMUM_MESSAGE_SIZE, Pointer_File);
		fclose(Pointer_File);
	}
	
	return 0;
}

/** Read the memory-shared log file to fetch latest log message.
 * @param Offset An optional offset to read the file from (set to 0 to have no offset).
 * @param Pointer_Log_Type On output, contain the log type number (a type is set by DBDEFTYPE message).
 * @param Pointer_String_Message On output, contain a zero-terminated string corresponding to the log message.
 * @return -1 if an error occurred,
 * @return 0 on success.
 */
static int ReadLogMessage(long Offset, int *Pointer_Log_Type, char *Pointer_String_Message)
{
	FILE *Pointer_File;
	unsigned char Byte;
	
	// Open the file everytime to start from the begining
	Pointer_File = fopen("Log.bin", "rb");
	if (Pointer_File == NULL)
	{
		printf("Error : failed to open log file to read last log (%s).\n", strerror(errno));
		return -1;
	}
	else
	{
		// Go to a specific offset if needed
		if (Offset > 0) fseek(Pointer_File, Offset, SEEK_SET);
		
		// Read the log type
		if (fread(&Byte, 1, 1, Pointer_File) != 1)
		{
			printf("Error : failed to read log type from log file (%s).\n", strerror(errno));
			return -1;
		}
		*Pointer_Log_Type = Byte;
		
		// Read the log message
		fread(Pointer_String_Message, 1, LOG_MAXIMUM_MESSAGE_SIZE, Pointer_File);
		
		fclose(Pointer_File);
	}
	
	return 0;
}

/** The standard callback called when the window receives a message. */
static LRESULT CALLBACK WindowProcedure(HWND Handle, UINT Message_ID, WPARAM First_Parameter, LPARAM Second_Parameter)
{
	char String_Message[LOG_MAXIMUM_MESSAGE_SIZE];
	int Log_Type;
	
	//if (Message_ID > 0xC00) printf("MGS : %X\n", Message_ID);
	
	// Handle only useful messages (a switch can't be used because some message IDs are dynamic)
	if (Message_ID == WM_DESTROY) exit(EXIT_SUCCESS);
	// Core Design "UM_DBLOGOUT" message
	else if (Message_ID == Window_Message_ID_UM_DBLOGOUT)
	{
		// Retrieve log message
		ReadLogMessage((long) Second_Parameter, &Log_Type, String_Message);
		
		if ((Log_Type < 0) || (Log_Type >= LOG_TYPES_COUNT))
		{
			printf("Error : the log type number (%d) is not in the allowed range.\n", Log_Type + 1);
			return 0;
		}
		
		// Display log with right color
		printf("\033[%dm[%s]\033[0m %s\n", Log_Types[Log_Type].Displaying_Color, Log_Types[Log_Type].String_Name, String_Message);
	}
	// Core Design "UM_DBCLEARLOG" message
	else if (Message_ID == Window_Message_ID_UM_DBCLEARLOG)
	{
		printf("UM_DBCLEARLOG\n");
	}
	// Core Design "UM_DBDEFTYPE" message
	else if (Message_ID == Window_Message_ID_UM_DBDEFTYPE)
	{
		// Get type name
		ReadLogType(String_Message); // Recycle String_Message variable
		printf("\033[45m[DEFTYPE]\033[0m type ID : %d, type name : '%s'\n", Defined_Log_Types_Count, String_Message);
		
		// Make sure there is enough room in the log types array
		if (Defined_Log_Types_Count >= LOG_TYPES_COUNT)
		{
			printf("Error : log types array is too small, consider increasing its size.\n");
			return 0;
		}
		
		// Store type name
		strncpy(Log_Types[Defined_Log_Types_Count].String_Name, String_Message, sizeof(Log_Types[0].String_Name));
		Defined_Log_Types_Count++;
	}
	// Core Design "UM_DBCOMMAND" message
	else if (Message_ID == Window_Message_ID_UM_DBCOMMAND)
	{
		printf("UM_DBCOMMAND\n");
	}
	else return DefWindowProc(Handle, Message_ID, First_Parameter, Second_Parameter);
	
	return 0;
}

/** Create the window Tomb Raider executable expects to send logs to.
 * @return -1 if the window could not be created,
 * @return 0 on success.
 */
static int CreateApplicationWindow(HINSTANCE Handle_Application_Instance)
{
	WNDCLASS Window_Class;
	HANDLE Handle_Window;
	
	// Create a window class with the specific names searched by Tomb Raider executable
	Window_Class.style = 0;
	Window_Class.lpfnWndProc = WindowProcedure;
	Window_Class.cbClsExtra = 0;
	Window_Class.cbWndExtra = 0;
	Window_Class.hInstance = Handle_Application_Instance;
	Window_Class.hIcon = NULL;
	Window_Class.hCursor = NULL;
	Window_Class.hbrBackground = (HBRUSH) COLOR_BACKGROUND;
	Window_Class.lpszMenuName = NULL;
	Window_Class.lpszClassName = STRING_WINDOW_CLASS;
	if (RegisterClass(&Window_Class) == 0)
	{
		printf("Error : failed to register the window class (%s).\n", strerror(errno));
		return -1;
	}
	
	// Create the window itself with a specific caption, as it is also searched by the Tomb Raider executable
	Handle_Window = CreateWindow(STRING_WINDOW_CLASS, "DBLog Server", WS_BORDER | WS_CAPTION | WS_SYSMENU, 0, 0, 200, 100, NULL, NULL, Handle_Application_Instance, NULL);
	if (Handle_Window == NULL)
	{
		printf("Error : failed to create the window (%s).\n", strerror(errno));
		return -1;
	}
	
	// Make the window visible
	ShowWindow(Handle_Window, SW_SHOW);
	
	return 0;
}

/** Get and identifier for all user messages used by Tomb Raider logging system.
 * @return -1 if an error occurred,
 * @return 0 on success.
 */
static int RegisterWindowUserMessages(void)
{
	// UM_DBLOGOUT message
	Window_Message_ID_UM_DBLOGOUT = RegisterWindowMessage("UM_DBLOGOUT");
	if (Window_Message_ID_UM_DBLOGOUT == 0)
	{
		printf("Error : failed to register UM_DBLOGOUT message (%s).\n", strerror(errno));
		return -1;
	}
	
	// UM_DBCLEARLOG message
	Window_Message_ID_UM_DBCLEARLOG = RegisterWindowMessage("UM_DBCLEARLOG");
	if (Window_Message_ID_UM_DBCLEARLOG == 0)
	{
		printf("Error : failed to register UM_DBCLEARLOG message (%s).\n", strerror(errno));
		return -1;
	}
	
	// UM_DBDEFTYPE message
	Window_Message_ID_UM_DBDEFTYPE = RegisterWindowMessage("UM_DBDEFTYPE");
	if (Window_Message_ID_UM_DBDEFTYPE == 0)
	{
		printf("Error : failed to register UM_DBDEFTYPE message (%s).\n", strerror(errno));
		return -1;
	}
	
	// UM_DBCOMMAND message
	Window_Message_ID_UM_DBCOMMAND = RegisterWindowMessage("UM_DBCOMMAND");
	if (Window_Message_ID_UM_DBCOMMAND == 0)
	{
		printf("Error : failed to register UM_DBCOMMAND message (%s).\n", strerror(errno));
		return -1;
	}
	
	return 0;
}

/** Gracefully close meaning resources on program exit. */
static void Exit(void)
{
	CloseHandle(Handle_Memory_Mapping);
	CloseHandle(Handle_Binary_File);
	fclose(Pointer_Output_File);
	
	printf("Program successfully exited.\n");
}

//-------------------------------------------------------------------------------------------------
// Entry point
//-------------------------------------------------------------------------------------------------
int APIENTRY WinMain(HINSTANCE Handle_Application_Instance, HINSTANCE __attribute__((unused)) Handle_Application_Previous_Instance, LPSTR __attribute__((unused)) String_Command_Line, int __attribute__((unused)) Window_Show_Mode)
{
	int Return_Value;
	MSG Message;
	
	// Create the file that will be memory-mapped and where Tomb Raider executable will write logs
	Handle_Binary_File = CreateFile("Log.bin", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 0, NULL);
	if (Handle_Binary_File == INVALID_HANDLE_VALUE)
	{
		printf("Error : failed to create the binary log file (%s).\n", strerror(errno));
		return EXIT_FAILURE;
	}
	
	// Memory-map the file, so Tomb Raider executable can access it
	Handle_Memory_Mapping = CreateFileMapping(Handle_Binary_File, NULL, PAGE_READWRITE, 0, 2 * 1024 * 1024, "DBLOGMAPMEM");
	if (Handle_Memory_Mapping == NULL)
	{
		printf("Error : failed to create the binary log file memory mapping (%s).\n", strerror(errno));
		return EXIT_FAILURE;
	}
	
	// Try to open the file that will contain all received logs in an human-readable way
	Pointer_Output_File = fopen("Log.txt", "w");
	if (Pointer_Output_File == NULL)
	{
		printf("Error : could not open the output file (%s).\n", strerror(errno));
		return EXIT_FAILURE;
	}
	
	// Register all user application messages, so they match Tomb Raider executable ones
	if (RegisterWindowUserMessages() != 0) return EXIT_FAILURE;
	
	// Make sure everything if well closed when quitting program
	atexit(Exit);
	
	// Create the application window Tomb Raider executable will search for (create it now that everything is ready to answer window messages)
	if (CreateApplicationWindow(Handle_Application_Instance) != 0) return EXIT_FAILURE;

	// Process messages
	while (1)
	{
		// Get next available message
		Return_Value = GetMessage(&Message, NULL, 0, 0);
		if (Return_Value == -1)
		{
			printf("Error : could not get the next message (%s).\n", strerror(errno));
			return EXIT_FAILURE;
		}
		if (Return_Value == 0) break;
		
		// Process the message
		TranslateMessage(&Message); 
		DispatchMessage(&Message); 
	}
	
	return EXIT_SUCCESS;
}
