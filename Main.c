/** @file Main.c
 * Capture and write to a file all logs generated by Tomb Raider Chronicle executable.
 * @author Adrien RICCIARDI
 */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

//-------------------------------------------------------------------------------------------------
// Private constants
//-------------------------------------------------------------------------------------------------
/** Tomb Raider executable searches for this window class when trying to send logs to logging program. */
#define STRING_WINDOW_CLASS "DBLogWindowClass"

//-------------------------------------------------------------------------------------------------
// Private variables
//-------------------------------------------------------------------------------------------------
/** This file is memory mapped, it is where the Tomb Raider executable writes. */
HANDLE Handle_Binary_File;
/** The memory-map shared between this program and Tomb Raider executable. */
HANDLE Handle_Memory_Mapping;

/** Write the received logs to this file. */
static FILE *Pointer_Output_File;

//-------------------------------------------------------------------------------------------------
// Private functions
//-------------------------------------------------------------------------------------------------
static char *ReadLogLine(void)
{
	static char Buffer[2048]; // Should be enough for a single message
	FILE *Pointer_File;
	
	// Open the file everytime to start from the begining TODO : rewind
	Pointer_File = fopen("Log.bin", "rb");
	if (Pointer_File == NULL)
	{
		printf("Error : failed to read log data (%s).\n", strerror(errno));
		Buffer[0] = 0;
	}
	else
	{
		fread(Buffer, 1, sizeof(Buffer), Pointer_File);
		fclose(Pointer_File);
	}
	
	return Buffer;
}

/** The standard callback called when the window receives a message. */
static LRESULT CALLBACK WindowProcedure(HWND Handle, UINT Message_ID, WPARAM First_Parameter, LPARAM Second_Parameter)
{
	if (Message_ID > 0xC00) printf("MGS : %X\n", Message_ID);
	
	// Handle only useful messages
	switch (Message_ID) 
    {
		case WM_DESTROY:
			exit(EXIT_SUCCESS);
			break; // To make the compiler happy
			
		case 0xC226:
			//printf("\033[32m[DEBUG ?]\033[0m %s\n", ReadLogLine());
			break;
		
		case 0xC227:
			printf("C227\n");
			break;
			
		case 0xC228:
			printf("\033[33m[INFO ?]\033[0m %s\n", ReadLogLine());
			break;
		
		default:
			return DefWindowProc(Handle, Message_ID, First_Parameter, Second_Parameter); 
	}
	
	return 0;
}

/** Create the window Tomb Raider executable expects to send logs to.
 * @return -1 if the window could not be created,
 * @return 0 on success.
 */
static int CreateApplicationWindow(HINSTANCE Handle_Application_Instance)
{
	WNDCLASS Window_Class;
	HANDLE Handle_Window;
	
	// Create a window class with the specific names searched by Tomb Raider executable
	Window_Class.style = 0;
	Window_Class.lpfnWndProc = WindowProcedure;
	Window_Class.cbClsExtra = 0;
	Window_Class.cbWndExtra = 0;
	Window_Class.hInstance = Handle_Application_Instance;
	Window_Class.hIcon = NULL;
	Window_Class.hCursor = NULL;
	Window_Class.hbrBackground = (HBRUSH) COLOR_BACKGROUND;
	Window_Class.lpszMenuName = NULL;
	Window_Class.lpszClassName = STRING_WINDOW_CLASS;
	if (RegisterClass(&Window_Class) == 0)
	{
		printf("Error : failed to register the window class (%s).\n", strerror(errno));
		return -1;
	}
	
	// Create the window itself with a specific caption, as it is also searched by the Tomb Raider executable
	Handle_Window = CreateWindow(STRING_WINDOW_CLASS, "DBLog Server", WS_BORDER | WS_CAPTION | WS_SYSMENU, 0, 0, 200, 100, NULL, NULL, Handle_Application_Instance, NULL);
	if (Handle_Window == NULL)
	{
		printf("Error : failed to create the window (%s).\n", strerror(errno));
		return -1;
	}
	
	// Make the window visible
	ShowWindow(Handle_Window, SW_SHOW);
	
	return 0;
}

/** Gracefully close meaning resources on program exit. */
static void Exit(void)
{
	CloseHandle(Handle_Memory_Mapping);
	CloseHandle(Handle_Binary_File);
	fclose(Pointer_Output_File);
	
	printf("Program successfully exited.\n");
}

//-------------------------------------------------------------------------------------------------
// Entry point
//-------------------------------------------------------------------------------------------------
int APIENTRY WinMain(HINSTANCE Handle_Application_Instance, HINSTANCE __attribute__((unused)) Handle_Application_Previous_Instance, LPSTR __attribute__((unused)) String_Command_Line, int __attribute__((unused)) Window_Show_Mode)
{
	int Return_Value;
	MSG Message;
	
	// Create the file that will be memory-mapped and where Tomb Raider executable will write logs
	Handle_Binary_File = CreateFile("Log.bin", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 0, NULL);
	if (Handle_Binary_File == INVALID_HANDLE_VALUE)
	{
		printf("Error : failed to create the binary log file (%s).\n", strerror(errno));
		return EXIT_FAILURE;
	}
	
	// Memory-map the file, so Tomb Raider executable can access it
	Handle_Memory_Mapping = CreateFileMapping(Handle_Binary_File, NULL, PAGE_READWRITE, 0, 2 * 1024 * 1024, "DBLOGMAPMEM");
	if (Handle_Memory_Mapping == NULL)
	{
		printf("Error : failed to create the binary log file memory mapping (%s).\n", strerror(errno));
		return EXIT_FAILURE;
	}
	
	// Try to open the file that will contain all received logs in an human-readable way
	Pointer_Output_File = fopen("Log.txt", "w");
	if (Pointer_Output_File == NULL)
	{
		printf("Error : could not open the output file (%s).\n", strerror(errno));
		return EXIT_FAILURE;
	}
	
	// Make sure everything if well closed when quitting program
	atexit(Exit);
	
	// Create the application window Tomb Raider executable will search for (create it now that everything is ready to answer window messages)
	if (CreateApplicationWindow(Handle_Application_Instance) != 0) return EXIT_FAILURE;

	// Process messages
	while (1)
	{
		// Get next available message
		Return_Value = GetMessage(&Message, NULL, 0, 0);
		if (Return_Value == -1)
		{
			printf("Error : could not get the next message (%s).\n", strerror(errno));
			return EXIT_FAILURE;
		}
		if (Return_Value == 0) break;
		
		// Process the message
		TranslateMessage(&Message); 
		DispatchMessage(&Message); 
	}
	
	return EXIT_SUCCESS;
}
