/** @file Main.c
 * Capture and write to a file all logs generated by Tomb Raider Chronicle executable.
 * @author Adrien RICCIARDI
 */
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

//-------------------------------------------------------------------------------------------------
// Private constants
//-------------------------------------------------------------------------------------------------
/** Tomb Raider executable searches for this window class when trying to send logs to logging program. */
#define STRING_WINDOW_CLASS "DBLogWindowClass"

//-------------------------------------------------------------------------------------------------
// Private variables
//-------------------------------------------------------------------------------------------------
/** This file is memory mapped, it is where the Tomb Raider executable writes. */
HANDLE Handle_Binary_File;
/** The memory-map shared between this program and Tomb Raider executable. */
HANDLE Handle_Memory_Mapping;

/** Write the received logs to this file. */
static FILE *Pointer_Output_File;

/** Contain the UM_DBLOGOUT message dynamic identifier. */
static UINT Window_Message_ID_UM_DBLOGOUT;
/** Contain the UM_DBCLEARLOG message dynamic identifier. */
static UINT Window_Message_ID_UM_DBCLEARLOG;
/** Contain the UM_DBDEFTYPE message dynamic identifier. */
static UINT Window_Message_ID_UM_DBDEFTYPE;
/** Contain the UM_DBCOMMAND message dynamic identifier. */
static UINT Window_Message_ID_UM_DBCOMMAND;

//-------------------------------------------------------------------------------------------------
// Private functions
//-------------------------------------------------------------------------------------------------
/** Read the memory-shared log file to fetch latest data.
 * @param Offset An optional offset to read the file from (set to 0 to have no offset).
 * @return A zero-terminated string corresponding to the read log.
 */
static char *ReadLog(long Offset)
{
	static char Buffer[2048]; // Should be enough for a single message
	FILE *Pointer_File;
	
	// Open the file everytime to start from the begining
	Pointer_File = fopen("Log.bin", "rb");
	if (Pointer_File == NULL)
	{
		printf("Error : failed to read log data (%s).\n", strerror(errno));
		Buffer[0] = 0;
	}
	else
	{
		// Go to a specific offset if needed
		if (Offset > 0) fseek(Pointer_File, Offset, SEEK_SET);
		
		fread(Buffer, 1, sizeof(Buffer), Pointer_File);
		fclose(Pointer_File);
	}
	
	return Buffer;
}

/** The standard callback called when the window receives a message. */
static LRESULT CALLBACK WindowProcedure(HWND Handle, UINT Message_ID, WPARAM First_Parameter, LPARAM Second_Parameter)
{
	//if (Message_ID > 0xC00) printf("MGS : %X\n", Message_ID);
	
	// Handle only useful messages (a switch can't be used because some message IDs are dynamic)
	if (Message_ID == WM_DESTROY) exit(EXIT_SUCCESS);
	// Core Design "UM_DBLOGOUT" message
	else if (Message_ID == Window_Message_ID_UM_DBLOGOUT)
	{
		printf("\033[32m[LOG]\033[0m %s\n", ReadLog((long) Second_Parameter));
	}
	// Core Design "UM_DBCLEARLOG" message
	else if (Message_ID == Window_Message_ID_UM_DBCLEARLOG)
	{
		printf("UM_DBCLEARLOG\n");
	}
	// Core Design "UM_DBDEFTYPE" message
	else if (Message_ID == Window_Message_ID_UM_DBDEFTYPE)
	{
		//printf("DBDEFTYPE w=%llu l=%lld %s\n", First_Parameter, Second_Parameter, ReadLog(0));
		printf("\033[33m[DEFTYPE]\033[0m w=%llu l=%lld %s\n", First_Parameter, Second_Parameter, ReadLog(0));
	}
	// Core Design "UM_DBCOMMAND" message
	else if (Message_ID == Window_Message_ID_UM_DBCOMMAND)
	{
		printf("UM_DBCOMMAND\n");
	}
	else return DefWindowProc(Handle, Message_ID, First_Parameter, Second_Parameter);
	
	return 0;
}

/** Create the window Tomb Raider executable expects to send logs to.
 * @return -1 if the window could not be created,
 * @return 0 on success.
 */
static int CreateApplicationWindow(HINSTANCE Handle_Application_Instance)
{
	WNDCLASS Window_Class;
	HANDLE Handle_Window;
	
	// Create a window class with the specific names searched by Tomb Raider executable
	Window_Class.style = 0;
	Window_Class.lpfnWndProc = WindowProcedure;
	Window_Class.cbClsExtra = 0;
	Window_Class.cbWndExtra = 0;
	Window_Class.hInstance = Handle_Application_Instance;
	Window_Class.hIcon = NULL;
	Window_Class.hCursor = NULL;
	Window_Class.hbrBackground = (HBRUSH) COLOR_BACKGROUND;
	Window_Class.lpszMenuName = NULL;
	Window_Class.lpszClassName = STRING_WINDOW_CLASS;
	if (RegisterClass(&Window_Class) == 0)
	{
		printf("Error : failed to register the window class (%s).\n", strerror(errno));
		return -1;
	}
	
	// Create the window itself with a specific caption, as it is also searched by the Tomb Raider executable
	Handle_Window = CreateWindow(STRING_WINDOW_CLASS, "DBLog Server", WS_BORDER | WS_CAPTION | WS_SYSMENU, 0, 0, 200, 100, NULL, NULL, Handle_Application_Instance, NULL);
	if (Handle_Window == NULL)
	{
		printf("Error : failed to create the window (%s).\n", strerror(errno));
		return -1;
	}
	
	// Make the window visible
	ShowWindow(Handle_Window, SW_SHOW);
	
	return 0;
}

/** Get and identifier for all user messages used by Tomb Raider logging system.
 * @return -1 if an error occurred,
 * @return 0 on success.
 */
static int RegisterWindowUserMessages(void)
{
	// UM_DBLOGOUT message
	Window_Message_ID_UM_DBLOGOUT = RegisterWindowMessage("UM_DBLOGOUT");
	if (Window_Message_ID_UM_DBLOGOUT == 0)
	{
		printf("Error : failed to register UM_DBLOGOUT message (%s).\n", strerror(errno));
		return -1;
	}
	
	// UM_DBCLEARLOG message
	Window_Message_ID_UM_DBCLEARLOG = RegisterWindowMessage("UM_DBCLEARLOG");
	if (Window_Message_ID_UM_DBCLEARLOG == 0)
	{
		printf("Error : failed to register UM_DBCLEARLOG message (%s).\n", strerror(errno));
		return -1;
	}
	
	// UM_DBDEFTYPE message
	Window_Message_ID_UM_DBDEFTYPE = RegisterWindowMessage("UM_DBDEFTYPE");
	if (Window_Message_ID_UM_DBDEFTYPE == 0)
	{
		printf("Error : failed to register UM_DBDEFTYPE message (%s).\n", strerror(errno));
		return -1;
	}
	
	// UM_DBCOMMAND message
	Window_Message_ID_UM_DBCOMMAND = RegisterWindowMessage("UM_DBCOMMAND");
	if (Window_Message_ID_UM_DBCOMMAND == 0)
	{
		printf("Error : failed to register UM_DBCOMMAND message (%s).\n", strerror(errno));
		return -1;
	}
	
	return 0;
}

/** Gracefully close meaning resources on program exit. */
static void Exit(void)
{
	CloseHandle(Handle_Memory_Mapping);
	CloseHandle(Handle_Binary_File);
	fclose(Pointer_Output_File);
	
	printf("Program successfully exited.\n");
}

//-------------------------------------------------------------------------------------------------
// Entry point
//-------------------------------------------------------------------------------------------------
int APIENTRY WinMain(HINSTANCE Handle_Application_Instance, HINSTANCE __attribute__((unused)) Handle_Application_Previous_Instance, LPSTR __attribute__((unused)) String_Command_Line, int __attribute__((unused)) Window_Show_Mode)
{
	int Return_Value;
	MSG Message;
	
	// Create the file that will be memory-mapped and where Tomb Raider executable will write logs
	Handle_Binary_File = CreateFile("Log.bin", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, 0, NULL);
	if (Handle_Binary_File == INVALID_HANDLE_VALUE)
	{
		printf("Error : failed to create the binary log file (%s).\n", strerror(errno));
		return EXIT_FAILURE;
	}
	
	// Memory-map the file, so Tomb Raider executable can access it
	Handle_Memory_Mapping = CreateFileMapping(Handle_Binary_File, NULL, PAGE_READWRITE, 0, 2 * 1024 * 1024, "DBLOGMAPMEM");
	if (Handle_Memory_Mapping == NULL)
	{
		printf("Error : failed to create the binary log file memory mapping (%s).\n", strerror(errno));
		return EXIT_FAILURE;
	}
	
	// Try to open the file that will contain all received logs in an human-readable way
	Pointer_Output_File = fopen("Log.txt", "w");
	if (Pointer_Output_File == NULL)
	{
		printf("Error : could not open the output file (%s).\n", strerror(errno));
		return EXIT_FAILURE;
	}
	
	// Register all user application messages, so they match Tomb Raider executable ones
	if (RegisterWindowUserMessages() != 0) return EXIT_FAILURE;
	
	// Make sure everything if well closed when quitting program
	atexit(Exit);
	
	// Create the application window Tomb Raider executable will search for (create it now that everything is ready to answer window messages)
	if (CreateApplicationWindow(Handle_Application_Instance) != 0) return EXIT_FAILURE;

	// Process messages
	while (1)
	{
		// Get next available message
		Return_Value = GetMessage(&Message, NULL, 0, 0);
		if (Return_Value == -1)
		{
			printf("Error : could not get the next message (%s).\n", strerror(errno));
			return EXIT_FAILURE;
		}
		if (Return_Value == 0) break;
		
		// Process the message
		TranslateMessage(&Message); 
		DispatchMessage(&Message); 
	}
	
	return EXIT_SUCCESS;
}
